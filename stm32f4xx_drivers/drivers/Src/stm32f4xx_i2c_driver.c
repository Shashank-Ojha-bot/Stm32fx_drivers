/*
 * stm32f4xx_i2c_driver.c
 *
 *  Created on: Jul 14, 2020
 *      Author: Shashank
 */


#include<stdint.h>
#include<stdlib.h>
#include "stm32f4xx_i2c_driver.h"
static void I2C_clear_Addr_flag(I2C_RegDef_t *pI2Cx);
uint32_t AHB1_Prescalar[]={2,4,8,16,64,128,256,512};
uint32_t APB1_Prescalar[]={2,4,8,16};

static void I2C_clear_Addr_flag(I2C_RegDef_t *pI2Cx)
{
	uint32_t *pdummy=0;
    *pdummy=pI2Cx->SR1;
	*pdummy=pI2Cx->SR2;
	free(pdummy);
}

void I2C_PeriClockControl(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi==ENABLE)
	{
		if(pI2Cx==I2C1)
		{
			I2C1_PCLK_EN;
		}
		if(pI2Cx==I2C2)
		{
			I2C2_PCLK_EN;
		}
		if(pI2Cx==I2C3)
		{
			I2C3_PCLK_EN;
		}
	}
	else
	{
		if(pI2Cx==I2C1)
		{
			I2C1_PCLK_DI;
		}
		if(pI2Cx==I2C2)
		{
			I2C2_PCLK_DI;
		}
		if(pI2Cx==I2C3)
		{
			I2C3_PCLK_DI;
		}
	}
}
uint32_t RCC_pll_output()
{
	return 0;
}

uint32_t RCC_pclk_value()
{
	uint32_t Sysclk,temp;
	uint32_t pclk1;
	uint8_t pclksrc,ahb1,apb1;
	pclksrc=(RCC->RCC_CFGR<<2) & 0x3;
	if(pclksrc==0)
	{
		Sysclk=16000000;            //Internal HSI(RC oscillator)
	}
	else if(pclksrc==1)
	{
	    Sysclk=8000000;             //External HSE(Crystal )
	}
	else if(pclksrc==2)
	{
		Sysclk=RCC_pll_output();    //Phase locked loop
	}
	temp=(RCC->RCC_CFGR<<4) & 0xF;   //AHB1 Prescalar to decide speed of ahb1 bus
	if(temp<8)
	{
		ahb1=1;
	}
	else
	{
		ahb1=AHB1_Prescalar[temp-8];
	}
	temp=(RCC->RCC_CFGR<<10) & 0x7;
	if(temp<4)
	{
		apb1=1;
	}
	else
	{
		apb1=APB1_Prescalar[temp-4];
	}
	pclk1=(Sysclk/ahb1)/apb1;
	return pclk1;
}

void I2C_DeInit(I2C_RegDef_t *pI2Cx)
{
	if(pI2Cx==I2C1)
	{
		I2C1_REG_RESET();
	}
	if(pI2Cx==I2C2)
    {
	    I2C2_REG_RESET();
	}
	if(pI2Cx==I2C3)
	{
		I2C3_REG_RESET();
	}
}

void I2C_Init(I2C_Handle_t* pI2CHandle)
{
	uint32_t tempreg=0;

	//ACK control Bit configure
	tempreg|=pI2CHandle->I2C_Config.I2C_ACK_CONTROL<<10;
	pI2CHandle->pI2Cx->CR1=tempreg;

	//FREQ of the CR2 register configure
	tempreg=0;
	tempreg|=RCC_pclk_value();
	pI2CHandle->pI2Cx->CR2=(tempreg & 0x3F);

	//Device own address in OAR1 Register
	tempreg|=pI2CHandle->I2C_Config.I2C_DeviceAddress<<1;    //valid only for slave(address based communication)
	tempreg|=(1<<14);
	pI2CHandle->pI2Cx->OAR1=tempreg;

	//CCR Bits of CCR register
	uint16_t ccr_value;
	tempreg=0;
	if(pI2CHandle->I2C_Config.I2C_SCL_SPEED==I2C_SCL_SPEED_SM)
	{
		ccr_value=(RCC_pclk_value()/(2*pI2CHandle->I2C_Config.I2C_SCL_SPEED));
		tempreg |= ccr_value & 0xFFF;
	}
	else
	{
		tempreg |= 1<<15;
		tempreg |= pI2CHandle->I2C_Config.I2C_FM_DutyCycle<<14;
		if(pI2CHandle->I2C_Config.I2C_FM_DutyCycle==0)
		{
			ccr_value=(RCC_pclk_value()/(3*pI2CHandle->I2C_Config.I2C_SCL_SPEED));
			tempreg |= ccr_value & 0xFFF;
		}
		else
		{
			ccr_value=(RCC_pclk_value()/(25*pI2CHandle->I2C_Config.I2C_SCL_SPEED));
			tempreg |= ccr_value & 0xFFF;
		}
	}
	pI2CHandle->pI2Cx->CCR=tempreg;
}

void I2C_MasterSendData(I2C_Handle_t *pI2CHandle,uint8_t *pTxBuffer,uint32_t Len,uint8_t Slave_addr)
{

	//Generate the start condition
	pI2CHandle->pI2Cx->CR1 |= (1<<8);

	//confirm the start condition is generated by checking the SB flag
	//Until the SB flag is reset the clock will be stretched
	while(!(pI2CHandle->pI2Cx->SR1 & (1<<0)));

	//First sending the slave address and waiting for ack before sending the data.

	//Writing the address into the data register
	Slave_addr=Slave_addr<<1;  //making space for r/w bit
	Slave_addr &=~(1);     //or (1<<0) ;clearing the 0th bit because r/w 0 is write
	pI2CHandle->pI2Cx->DR= Slave_addr;
	//Until ADDR=1 clock will be stretched
	while(!(pI2CHandle->pI2Cx->SR1 & (1<<1)));
	I2C_clear_Addr_flag(pI2CHandle->pI2Cx);
	while(Len>0)
	{
	//Wait for TXE=1
	while(!(pI2CHandle->pI2Cx->SR1 & (1<<7)));
	//Writing data 1 into DR
	pI2CHandle->pI2Cx->DR= *pTxBuffer;
	pTxBuffer++;
	Len--;
	}

	while(!(pI2CHandle->pI2Cx->SR1 & (1<<7)));
	while(!(pI2CHandle->pI2Cx->SR1 & (1<<2)));

	//generate stop condition
	pI2CHandle->pI2Cx->CR1 |= (1<<9);
}

void I2C_ReceiveSendData(I2C_Handle_t *pI2CHandle,uint8_t *pRxBuffer,uint32_t Len,uint8_t Slave_addr)
{
	//Generate the start condition
		pI2CHandle->pI2Cx->CR1 |= (1<<8);

	//confirm the start condition is generated by checking the SB flag
	//Until the SB flag is reset the clock will be stretched
	while(!(pI2CHandle->pI2Cx->SR1 & (1<<0)));

	//Writing the address into the data register
	Slave_addr=Slave_addr<<1;  //making space for r/w bit
	Slave_addr |=(1);     //or (1<<0) ;setting the 0th bit because r/w 1 is read
	pI2CHandle->pI2Cx->DR= Slave_addr;

	//Wait until ADDR is 1
	while(!(pI2CHandle->pI2Cx->SR1 & (1<<1)));
	if(Len==1)
	{
		pI2CHandle->pI2Cx->CR1 &=~(1<<10);  //to disable the ack to prevent next byte from sending
		pI2CHandle->pI2Cx->CR1 |=(1<<9);    //stop condition
		I2C_clear_Addr_flag(pI2CHandle->pI2Cx);
		//Wait until 1 byte is received(RXNE flag is set)
		while(!(pI2CHandle->pI2Cx->SR1 & (1<<6)));
		*pRxBuffer=(uint8_t)pI2CHandle->pI2Cx->DR;
		return;
	}
	if(Len>1)
	{I2C_clear_Addr_flag(pI2CHandle->pI2Cx);
		while(Len--)
		{
			while(!(pI2CHandle->pI2Cx->SR1 & (1<<6)));

			if(Len==2)
		{
			pI2CHandle->pI2Cx->CR1 &=~(1<<10);
			pI2CHandle->pI2Cx->CR1 |=(1<<9);
		}
		*pRxBuffer=(uint8_t)pI2CHandle->pI2Cx->DR;
		pRxBuffer++;
	}}

	/*enable the acking*/
	if(pI2CHandle->I2C_Config.I2C_ACK_CONTROL==I2C_ACK_ENABLE)
	{
	pI2CHandle->pI2Cx->CR1 |=(1<<10);
}}
